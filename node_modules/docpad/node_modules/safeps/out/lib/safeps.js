// Generated by CoffeeScript 1.6.3
var TaskGroup, extractOptsAndCallback, isWindows, safefs, safeps, typeChecker, _base, _ref, _ref1,
  __slice = [].slice;

safeps = null;

TaskGroup = require('taskgroup').TaskGroup;

typeChecker = require('typechecker');

safefs = require('safefs');

extractOptsAndCallback = require('extract-opts').extractOptsAndCallback;

isWindows = (typeof process !== "undefined" && process !== null ? (_ref = process.platform) != null ? _ref.indexOf('win') : void 0 : void 0) === 0;

if (global.safepsGlobal == null) {
  global.safepsGlobal = {};
}

if ((_base = global.safepsGlobal).pool == null) {
  _base.pool = new TaskGroup().setConfig({
    concurrency: (_ref1 = process.env.NODE_MAX_OPEN_PROCESSES) != null ? _ref1 : 100,
    pauseOnError: false
  }).run();
}

safeps = {
  openProcess: function(fn) {
    global.safepsGlobal.pool.addTask(fn);
    return safeps;
  },
  requireFresh: function(path) {
    var result;
    path = require('path').resolve(path);
    delete require.cache[path];
    result = require(path);
    delete require.cache[path];
    return result;
  },
  isWindows: function() {
    return isWindows;
  },
  getLocaleCode: function(lang) {
    var localeCode;
    if (lang == null) {
      lang = null;
    }
    if (lang == null) {
      lang = process.env.LANG || '';
    }
    localeCode = lang.replace(/\..+/, '').replace('-', '_').toLowerCase() || null;
    return localeCode;
  },
  getLanguageCode: function(localeCode) {
    var languageCode;
    if (localeCode == null) {
      localeCode = null;
    }
    localeCode = safeps.getLocaleCode(localeCode) || '';
    languageCode = localeCode.replace(/^([a-z]+)[_-]([a-z]+)$/i, '$1').toLowerCase() || null;
    return languageCode;
  },
  getCountryCode: function(localeCode) {
    var countryCode;
    if (localeCode == null) {
      localeCode = null;
    }
    localeCode = safeps.getLocaleCode(localeCode) || '';
    countryCode = localeCode.replace(/^([a-z]+)[_-]([a-z]+)$/i, '$2').toLowerCase() || null;
    return countryCode;
  },
  spawn: function(command, opts, next) {
    safeps.openProcess(function(closeProcess) {
      var code, pid, signal, spawn, stderr, stdout, tasks, _ref2;
      spawn = require('child_process').spawn;
      _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
      if (opts.safe == null) {
        opts.safe = true;
      }
      if (opts.env == null) {
        opts.env = process.env;
      }
      if (opts.read == null) {
        opts.read = true;
      }
      if (opts.output == null) {
        opts.output = false;
      }
      if (opts.stdin == null) {
        opts.stdin = null;
      }
      if (opts.env === false) {
        delete opts.env;
      }
      if (typeChecker.isString(command)) {
        command = command.split(' ');
      }
      pid = null;
      stdout = null;
      stderr = null;
      code = null;
      signal = null;
      tasks = new TaskGroup().once('complete', function(err) {
        closeProcess();
        return typeof next === "function" ? next(err, stdout, stderr, code, signal) : void 0;
      });
      if (opts.safe) {
        tasks.addTask(function(complete) {
          return safeps.getExecPath(command[0], function(err, execPath) {
            if (err) {
              return complete(err);
            }
            command[0] = execPath;
            return complete();
          });
        });
      }
      tasks.addTask(function(complete) {
        var d;
        d = require('domain').create();
        d.on('error', function(err) {
          return complete(err);
        });
        return d.run(function() {
          var _ref3, _ref4, _ref5, _ref6;
          pid = spawn(command[0], command.slice(1), opts);
          if (opts.read) {
            stdout = '';
            stderr = '';
            if ((_ref3 = pid.stdout) != null) {
              _ref3.on('data', function(data) {
                if (opts.output) {
                  process.stdout.write(data);
                }
                return stdout += data.toString();
              });
            }
            if ((_ref4 = pid.stderr) != null) {
              _ref4.on('data', function(data) {
                if (opts.output) {
                  process.stderr.write(data);
                }
                return stderr += data.toString();
              });
            }
          }
          pid.on('close', function(_code, _signal) {
            var err;
            code = _code;
            signal = _signal;
            err = null;
            if (code !== 0) {
              err = new Error(stderr || 'exited with a non-zero status code');
            }
            return complete(err);
          });
          if (opts.stdin) {
            if ((_ref5 = pid.stdin) != null) {
              _ref5.write(opts.stdin);
            }
            return (_ref6 = pid.stdin) != null ? _ref6.end() : void 0;
          }
        });
      });
      return tasks.run();
    });
    return this;
  },
  spawnMultiple: function(commands, opts, next) {
    var results, tasks, _ref2;
    _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
    if (opts.concurrency == null) {
      opts.concurrency = 1;
    }
    results = [];
    tasks = new TaskGroup().setConfig({
      concurrency: opts.concurrency
    }).once('complete', function(err) {
      return next(err, results);
    });
    if (!typeChecker.isArray(commands)) {
      commands = [commands];
    }
    commands.forEach(function(command) {
      return tasks.addTask(function(complete) {
        return safeps.spawn(command, opts, function() {
          var args, err;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          err = args[0] || null;
          results.push(args);
          return complete(err);
        });
      });
    });
    tasks.run();
    return this;
  },
  spawnCommand: function(command, args, opts, next) {
    var pieces, _ref2;
    if (args == null) {
      args = [];
    }
    _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
    pieces = [command].concat(args);
    safeps.spawn(pieces, opts, next);
    return this;
  },
  spawnCommands: function(command, multiArgs, opts, next) {
    var args, pieces, _i, _len, _ref2;
    if (multiArgs == null) {
      multiArgs = [];
    }
    _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
    pieces = [];
    for (_i = 0, _len = multiArgs.length; _i < _len; _i++) {
      args = multiArgs[_i];
      pieces.push([command].concat(args));
    }
    safeps.spawnMultiple(pieces, opts, next);
    return this;
  },
  exec: function(command, opts, next) {
    safeps.openProcess(function(closeProcess) {
      var exec, _ref2;
      exec = require('child_process').exec;
      _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
      if (opts.output == null) {
        opts.output = false;
      }
      if (opts.output) {
        opts.stdio = 'inherit';
        delete opts.output;
      }
      return exec(command, opts, function(err, stdout, stderr) {
        closeProcess();
        return typeof next === "function" ? next(err, stdout, stderr) : void 0;
      });
    });
    return this;
  },
  execMultiple: function(commands, opts, next) {
    var results, tasks, _ref2;
    _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
    if (opts.concurrency == null) {
      opts.concurrency = 1;
    }
    results = [];
    tasks = new TaskGroup().setConfig({
      concurrency: opts.concurrency
    }).once('complete', function(err) {
      return next(err, results);
    });
    if (!typeChecker.isArray(commands)) {
      commands = [commands];
    }
    commands.forEach(function(command) {
      return tasks.addTask(function(complete) {
        return safeps.exec(this.command, opts, function() {
          var args, err;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          err = args[0] || null;
          results.push(args);
          return complete(err);
        });
      });
    });
    tasks.run();
    return this;
  },
  determineExecPath: function(possibleExecPaths, next) {
    var execPath, pathUtil, tasks;
    pathUtil = require('path');
    execPath = null;
    tasks = new TaskGroup().once('complete', function(err) {
      return next(err, execPath);
    });
    possibleExecPaths.forEach(function(possibleExecPath) {
      if (!possibleExecPath) {
        return;
      }
      return tasks.addTask(function(complete) {
        if (execPath) {
          return complete();
        }
        possibleExecPath = pathUtil.resolve(possibleExecPath);
        return safefs.exists(possibleExecPath, function(exists) {
          if (!exists) {
            return complete();
          }
          return safeps.spawn([possibleExecPath, '--version'], function(err, stdout, stderr, code, signal) {
            if (((err != null ? err.message : void 0) || '').indexOf('spawn') !== -1) {
              return complete();
            }
            execPath = possibleExecPath;
            return tasks.exit();
          });
        });
      });
    });
    tasks.run();
    return this;
  },
  getEnvironmentPaths: function() {
    var environmentPaths, pathUtil;
    pathUtil = require('path');
    environmentPaths = process.env.PATH.split(pathUtil.delimiter);
    return environmentPaths;
  },
  getStandardExecPaths: function(execName) {
    var pathUtil, standardExecPaths;
    pathUtil = require('path');
    standardExecPaths = [process.cwd()].concat(safeps.getEnvironmentPaths());
    if (execName) {
      standardExecPaths = standardExecPaths.map(function(path) {
        return pathUtil.join(path, execName);
      });
    }
    return standardExecPaths;
  },
  getPossibleExecPaths: function(execName) {
    var possibleExecPaths, standardExecPath, standardExecPaths, _i, _len;
    if (isWindows && execName.indexOf('.') === -1) {
      standardExecPaths = safeps.getStandardExecPaths(execName);
      possibleExecPaths = [];
      for (_i = 0, _len = standardExecPaths.length; _i < _len; _i++) {
        standardExecPath = standardExecPaths[_i];
        possibleExecPaths.push(standardExecPath, standardExecPath + '.exe', standardExecPath + '.cmd', standardExecPath + '.bat');
      }
    } else {
      possibleExecPaths = safeps.getStandardExecPaths(execName);
    }
    return possibleExecPaths;
  },
  execPathCache: {},
  getExecPath: function(execName, next) {
    var execNameCapitalized, getExecMethodName, possibleExecPaths;
    if (execName.substr(0, 1) === '/' || execName.substr(1, 1) === ':') {
      return next(null, execName);
    }
    if (safeps.execPathCache[execName] != null) {
      return next(null, safeps.execPathCache[execName]);
    }
    execNameCapitalized = execName[0].toUpperCase() + execName.substr(1);
    getExecMethodName = 'get' + execNameCapitalized + 'Path';
    if (safeps[getExecMethodName] != null) {
      safeps[getExecMethodName](next);
    } else {
      possibleExecPaths = safeps.getPossibleExecPaths(execName);
      safeps.determineExecPath(possibleExecPaths, function(err, execPath) {
        if (err) {
          return next(err);
        }
        if (!execPath) {
          err = new Error('Could not locate the ' + execName + ' executable path');
          return next(err);
        }
        safeps.execPathCache[execName] = execPath;
        return next(null, execPath);
      });
    }
    return this;
  },
  getHomePath: function(next) {
    var homePath;
    if (safeps.cachedHomePath != null) {
      next(null, safeps.cachedHomePath);
      return this;
    }
    homePath = process.env.USERPROFILE || process.env.HOME;
    homePath || (homePath = null);
    safeps.cachedHomePath = homePath;
    next(null, homePath);
    return this;
  },
  getTmpPath: function(next) {
    var pathUtil, tmpDirName, tmpPath;
    if (safeps.cachedTmpPath != null) {
      next(null, safeps.cachedTmpPath);
      return this;
    }
    pathUtil = require('path');
    tmpDirName = isWindows ? 'temp' : 'tmp';
    tmpPath = process.env.TMPDIR || process.env.TMP || process.env.TEMP;
    if (!tmpPath) {
      safeps.getHomePath(function(err, homePath) {
        if (err) {
          return next(err);
        }
        tmpPath = pathUtil.resolve(homePath, tmpDirName);
        if (!tmpPath) {
          return tmpPath = isWindows ? pathUtil.resolve(process.env.windir || 'C:\\Windows', tmpDirName) : '/tmp';
        }
      });
    }
    tmpPath || (tmpPath = null);
    safeps.cachedTmpPath = tmpPath;
    next(null, tmpPath);
    return this;
  },
  getGitPath: function(next) {
    var execName, possibleExecPaths;
    if (safeps.cachedGitPath != null) {
      next(null, safeps.cachedGitPath);
      return this;
    }
    execName = isWindows ? 'git.exe' : 'git';
    possibleExecPaths = [];
    if (process.env.GIT_PATH) {
      possibleExecPaths.push(process.env.GIT_PATH);
    }
    if (process.env.GITPATH) {
      possibleExecPaths.push(process.env.GITPATH);
    }
    possibleExecPaths = possibleExecPaths.concat(safeps.getStandardExecPaths(execName)).concat(isWindows ? ["/Program Files (x64)/Git/bin/" + execName, "/Program Files (x86)/Git/bin/" + execName, "/Program Files/Git/bin/" + execName] : ["/usr/local/bin/" + execName, "/usr/bin/" + execName, "~/bin/" + execName]);
    safeps.determineExecPath(possibleExecPaths, function(err, execPath) {
      safeps.cachedGitPath = execPath;
      if (err) {
        return next(err);
      }
      if (!execPath) {
        err = new Error('Could not locate git binary');
        return next(err);
      }
      return next(null, execPath);
    });
    return this;
  },
  getNodePath: function(next) {
    var execName, possibleExecPaths;
    if (safeps.cachedNodePath != null) {
      next(null, safeps.cachedNodePath);
      return this;
    }
    execName = isWindows ? 'node.exe' : 'node';
    possibleExecPaths = [];
    if (process.env.NODE_PATH) {
      possibleExecPaths.push(process.env.NODE_PATH);
    }
    if (process.env.NODEPATH) {
      possibleExecPaths.push(process.env.NODEPATH);
    }
    if (/node(.exe)?$/.test(process.execPath)) {
      possibleExecPaths.push(process.execPath);
    }
    possibleExecPaths = possibleExecPaths.concat(safeps.getStandardExecPaths(execName)).concat(isWindows ? ["/Program Files (x64)/nodejs/" + execName, "/Program Files (x86)/nodejs/" + execName, "/Program Files/nodejs/" + execName] : ["/usr/local/bin/" + execName, "/usr/bin/" + execName, "~/bin/" + execName]);
    safeps.determineExecPath(possibleExecPaths, function(err, execPath) {
      safeps.cachedNodePath = execPath;
      if (err) {
        return next(err);
      }
      if (!execPath) {
        err = new Error('Could not locate node binary');
        return next(err);
      }
      return next(null, execPath);
    });
    return this;
  },
  getNpmPath: function(next) {
    var execName, possibleExecPaths;
    if (safeps.cachedNpmPath != null) {
      next(null, safeps.cachedNpmPath);
      return this;
    }
    execName = isWindows ? 'npm.cmd' : 'npm';
    possibleExecPaths = [];
    if (process.env.NPM_PATH) {
      possibleExecPaths.push(process.env.NPM_PATH);
    }
    if (process.env.NPMPATH) {
      possibleExecPaths.push(process.env.NPMPATH);
    }
    if (/node(.exe)?$/.test(process.execPath)) {
      possibleExecPaths.push(process.execPath.replace(/node(.exe)?$/, execName));
    }
    possibleExecPaths = possibleExecPaths.concat(safeps.getStandardExecPaths(execName)).concat(isWindows ? ["/Program Files (x64)/nodejs/" + execName, "/Program Files (x86)/nodejs/" + execName, "/Program Files/nodejs/" + execName] : ["/usr/local/bin/" + execName, "/usr/bin/" + execName, "~/node_modules/.bin/" + execName]);
    safeps.determineExecPath(possibleExecPaths, function(err, execPath) {
      safeps.cachedNpmPath = execPath;
      if (err) {
        return next(err);
      }
      if (!execPath) {
        err = new Error('Could not locate npm binary');
        return next(err);
      }
      return next(null, execPath);
    });
    return this;
  },
  initGitRepo: function(opts, next) {
    var commands, _ref2;
    _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
    if (opts.path) {
      opts.cwd = opts.path;
      delete opts.path;
    }
    opts.cwd || (opts.cwd = process.cwd());
    opts.remote || (opts.remote = 'origin');
    opts.branch || (opts.branch = 'master');
    commands = [];
    commands.push(['init']);
    if (opts.url) {
      commands.push(['remote', 'add', opts.remote, opts.url]);
    }
    commands.push(['fetch', opts.remote]);
    commands.push(['pull', opts.remote, opts.branch]);
    commands.push(['submodule', 'init']);
    commands.push(['submodule', 'update', '--recursive']);
    safeps.spawnCommands('git', commands, opts, next);
    return this;
  },
  initOrPullGitRepo: function(opts, next) {
    var _ref2,
      _this = this;
    _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
    if (opts.path) {
      opts.cwd = opts.path;
      delete opts.path;
    }
    opts.cwd || (opts.cwd = process.cwd());
    opts.remote || (opts.remote = 'origin');
    opts.branch || (opts.branch = 'master');
    safefs.ensurePath(opts.cwd, function(err, exists) {
      if (err) {
        return complete(err);
      }
      if (exists) {
        return safeps.spawnCommand('git', ['pull', opts.remote, opts.branch], opts, function() {
          var err, result;
          err = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return next(err, 'pull', result);
        });
      } else {
        return safeps.initGitRepo(opts, function(err, result) {
          return next(err, 'init', result);
        });
      }
    });
    return this;
  },
  initNodeModules: function(opts, next) {
    var nodeModulesPath, packageJsonPath, partTwo, pathUtil, _ref2;
    pathUtil = require('path');
    _ref2 = extractOptsAndCallback(opts, next), opts = _ref2[0], next = _ref2[1];
    if (opts.path) {
      opts.cwd = opts.path;
      delete opts.path;
    }
    opts.cwd || (opts.cwd = process.cwd());
    if (opts.args == null) {
      opts.args = [];
    }
    if (opts.force == null) {
      opts.force = false;
    }
    packageJsonPath = pathUtil.join(opts.cwd, 'package.json');
    nodeModulesPath = pathUtil.join(opts.cwd, 'node_modules');
    partTwo = function() {
      return safefs.exists(packageJsonPath, function(exists) {
        var command;
        if (!exists) {
          return next();
        }
        command = ['install'].concat(opts.args);
        return safeps.spawnCommand('npm', command, opts, next);
      });
    };
    if (opts.force === false) {
      safefs.exists(nodeModulesPath, function(exists) {
        if (exists) {
          return next();
        }
        return partTwo();
      });
    } else {
      partTwo();
    }
    return this;
  }
};

module.exports = safeps;
