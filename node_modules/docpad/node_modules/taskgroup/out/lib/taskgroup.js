// Generated by CoffeeScript 1.6.3
var EventEmitter, Task, TaskGroup, ambi,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ambi = require('ambi');

EventEmitter = require('events').EventEmitter;

Task = (function(_super) {
  __extends(Task, _super);

  Task.prototype.type = 'task';

  Task.prototype.result = null;

  Task.prototype.running = false;

  Task.prototype.completed = false;

  Task.prototype.parent = null;

  Task.prototype.taskDomain = null;

  Task.prototype.name = null;

  Task.prototype.method = null;

  Task.prototype.args = null;

  function Task() {
    var args, method, name;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    Task.__super__.constructor.apply(this, arguments);
    name = method = null;
    if (args.length) {
      if (args.length === 2) {
        name = args[0], method = args[1];
      } else if (args.length === 1) {
        method = args[0];
      }
    }
    this.setConfig({
      name: name,
      method: method
    });
    this;
  }

  Task.prototype.setConfig = function(opts) {
    var key, value;
    if (opts == null) {
      opts = {};
    }
    for (key in opts) {
      if (!__hasProp.call(opts, key)) continue;
      value = opts[key];
      this[key] = value;
    }
    return this;
  };

  Task.prototype.reset = function() {
    this.completed = false;
    this.running = false;
    this.result = null;
    return this;
  };

  Task.prototype.uncaughtExceptionCallback = function() {
    var args, err;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    err = args[0];
    if (!this.completed) {
      this.complete(args);
    }
    this.emit('error', err);
    return this;
  };

  Task.prototype.completionCallback = function() {
    var args, err;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (!this.completed) {
      this.complete(args);
      this.emit.apply(this, ['complete'].concat(__slice.call(this.result)));
    } else {
      err = new Error("A task's completion callback has fired when the task was already in a completed state, this is unexpected");
      this.emit('error', err);
    }
    return this;
  };

  Task.prototype.destroy = function() {
    this.removeAllListeners();
    return this;
  };

  Task.prototype.complete = function(result) {
    this.completed = true;
    this.running = false;
    this.result = result;
    return this;
  };

  Task.prototype.fire = function() {
    var args,
      _this = this;
    args = (this.args || []).concat([this.completionCallback.bind(this)]);
    if (this.taskDomain == null) {
      this.taskDomain = require('domain').create();
      this.taskDomain.on('error', this.uncaughtExceptionCallback.bind(this));
    }
    this.taskDomain.run(function() {
      return ambi.apply(null, [_this.method.bind(_this)].concat(__slice.call(args)));
    });
    return this;
  };

  Task.prototype.run = function() {
    var err;
    if (this.completed) {
      err = new Error("A task was about to run but it has already completed, this is unexpected");
      this.emit('error', err);
    } else {
      this.reset();
      this.running = true;
      this.emit('run');
      process.nextTick(this.fire.bind(this));
    }
    return this;
  };

  return Task;

})(EventEmitter);

TaskGroup = (function(_super) {
  __extends(TaskGroup, _super);

  TaskGroup.prototype.type = 'taskgroup';

  TaskGroup.prototype.running = 0;

  TaskGroup.prototype.remaining = null;

  TaskGroup.prototype.err = null;

  TaskGroup.prototype.results = null;

  TaskGroup.prototype.parent = null;

  TaskGroup.prototype.paused = true;

  TaskGroup.prototype.bubbleEvents = null;

  TaskGroup.prototype.name = null;

  TaskGroup.prototype.method = null;

  TaskGroup.prototype.concurrency = 1;

  TaskGroup.prototype.pauseOnError = true;

  function TaskGroup() {
    var args, me, method, name;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.addGroup = __bind(this.addGroup, this);
    this.addTask = __bind(this.addTask, this);
    me = this;
    TaskGroup.__super__.constructor.apply(this, arguments);
    if (this.results == null) {
      this.results = [];
    }
    if (this.remaining == null) {
      this.remaining = [];
    }
    if (this.bubbleEvents == null) {
      this.bubbleEvents = ['complete', 'run', 'error'];
    }
    name = method = null;
    if (args.length) {
      if (args.length === 2) {
        name = args[0], method = args[1];
      } else if (args.length === 1) {
        method = args[0];
      }
    }
    this.setConfig({
      name: name,
      method: method
    });
    process.nextTick(this.fire.bind(this));
    this.on('item.complete', this.itemCompletionCallback.bind(this));
    this.on('item.error', function(item, err) {
      me.stop();
      return me.emit('error', err);
    });
    this;
  }

  TaskGroup.prototype.setConfig = function(opts) {
    var key, value;
    if (opts == null) {
      opts = {};
    }
    for (key in opts) {
      if (!__hasProp.call(opts, key)) continue;
      value = opts[key];
      this[key] = value;
    }
    return this;
  };

  TaskGroup.prototype.fire = function() {
    var args;
    if (this.method) {
      args = [this.addGroup, this.addTask];
      this.addTask(this.method.bind(this)).setConfig({
        args: args,
        includeInResults: false
      });
      if (!this.parent) {
        this.run();
      }
    }
    return this;
  };

  TaskGroup.prototype.itemCompletionCallback = function() {
    var args, item;
    item = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (item.includeInResults !== false) {
      this.results.push(args);
    }
    if (args[0]) {
      this.err = args[0];
    }
    if (this.running > 0) {
      --this.running;
    }
    if (this.paused) {
      return;
    }
    if (!this.complete()) {
      this.nextItems();
    }
    return this;
  };

  TaskGroup.prototype.getTotals = function() {
    var completed, remaining, running, total;
    running = this.running;
    remaining = this.remaining.length;
    completed = this.results.length;
    total = running + remaining + completed;
    return {
      running: running,
      remaining: remaining,
      completed: completed,
      total: total
    };
  };

  TaskGroup.prototype.addItem = function(item) {
    var me;
    me = this;
    this.bubbleEvents.forEach(function(bubbleEvent) {
      return item.on(bubbleEvent, function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return me.emit.apply(me, ["item." + bubbleEvent, item].concat(__slice.call(args)));
      });
    });
    this.emit('item.add', item);
    this.remaining.push(item);
    if (!this.paused) {
      this.nextItems();
    }
    return item;
  };

  TaskGroup.prototype.createTask = function() {
    var args, task;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    task = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(Task, args, function(){});
    return task;
  };

  TaskGroup.prototype.addTask = function() {
    var args, me, task;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    me = this;
    task = this.createTask.apply(this, args).setConfig({
      parent: this
    });
    this.bubbleEvents.forEach(function(bubbleEvent) {
      return task.on(bubbleEvent, function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return me.emit.apply(me, ["task." + bubbleEvent, task].concat(__slice.call(args)));
      });
    });
    this.emit('task.add', task);
    return this.addItem(task);
  };

  TaskGroup.prototype.createGroup = function() {
    var args, group;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    group = (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(TaskGroup, args, function(){});
    return group;
  };

  TaskGroup.prototype.addGroup = function() {
    var args, group, me;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    me = this;
    group = this.createGroup.apply(this, args).setConfig({
      concurrency: this.concurrency,
      parent: this
    });
    this.bubbleEvents.forEach(function(bubbleEvent) {
      return group.on(bubbleEvent, function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return me.emit.apply(me, ["group." + bubbleEvent, group].concat(__slice.call(args)));
      });
    });
    this.emit('group.add', group);
    return this.addItem(group);
  };

  TaskGroup.prototype.hasItems = function() {
    return this.remaining.length !== 0;
  };

  TaskGroup.prototype.isReady = function() {
    return !this.concurrency || this.running < this.concurrency;
  };

  TaskGroup.prototype.nextItems = function() {
    var item, items, result;
    items = [];
    while (true) {
      item = this.nextItem();
      if (item) {
        items.push(item);
      } else {
        break;
      }
    }
    result = items.length ? items : false;
    return result;
  };

  TaskGroup.prototype.nextItem = function() {
    var nextItem;
    if (this.hasItems()) {
      if (this.isReady()) {
        nextItem = this.remaining.shift();
        ++this.running;
        nextItem.run();
        return nextItem;
      }
    }
    return false;
  };

  TaskGroup.prototype.complete = function() {
    var completed, empty, pause;
    pause = this.pauseOnError && this.err;
    empty = this.hasItems() === false && this.running === 0;
    completed = pause || empty;
    if (completed) {
      if (pause) {
        this.pause();
      }
      this.emit('complete', this.err, this.results);
      this.err = null;
      this.results = [];
    }
    return completed;
  };

  TaskGroup.prototype.clear = function() {
    var item, _i, _len, _ref;
    _ref = this.remaining.splice(0);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      item = _ref[_i];
      item.destroy();
    }
    return this;
  };

  TaskGroup.prototype.destroy = function() {
    this.stop();
    this.removeAllListeners();
    return this;
  };

  TaskGroup.prototype.stop = function() {
    this.pause();
    this.clear();
    return this;
  };

  TaskGroup.prototype.exit = function(err) {
    if (err) {
      this.err = err;
    }
    this.stop();
    this.running = 0;
    this.complete();
    return this;
  };

  TaskGroup.prototype.pause = function() {
    this.paused = true;
    return this;
  };

  TaskGroup.prototype.run = function() {
    var args, me;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    me = this;
    this.paused = false;
    this.emit('run');
    process.nextTick(function() {
      if (!me.complete()) {
        return me.nextItems();
      }
    });
    return this;
  };

  return TaskGroup;

})(EventEmitter);

module.exports = {
  Task: Task,
  TaskGroup: TaskGroup
};
